Git:

Git is by far the most widely used version control system available. It manages source code and tracks changes in your repository. As a distributed version control system, Git allows engineers to work together to minimize friction, maximize flow, and provide simpler collaboration and version history.

- Changes are tracked as commits and contain messages, author, and timestamp
- Utilizes branches to allow for parallel development
- Ability to rewind to a previous point in time when necessary
- Maintains version history
- Secure and resistant to corruption

All History related to commit metadata is contained within a hidden .git folder

What does Git track:

- Application code (source, test)
- Infrastucture code (config management, Dockerfiles)
- configuration (pipeline scripts, enviroment properties)
- metadata (READMEs, manifests)

Although Git can watch everything in your working directory, not everything on your local machine should be stored in Git.

- Built artifacts and test results
- Binaries
- Local system properties from IDE
- Secrets, passwords, and other security-sensitive data

You can add a .gitignore file to instruct git not to track changes to specific files and folders (ex: node_modules lol)

Common Git commands:

git init - Initializes a new local Git repository
git clone - Creates a local Git repository copied from a remote
git add - Stages local changes to be commited
git commit - Commits staged changes into git history
git fetch - Synchronizes information about a remote repository
git push - Pushes local commits to a remote repository
git pull - Pulls comits from a remote repository and merges them with a local copy
git branch - Provides information about different branches
git checkout - Changes the state of HEAD to a different branch or commit
git status - Displays current information about the state of your git repository
git log - Displays Git's commit history
git reset - Resets git history to the stat of a previous commit, permanently changing history
git rebase - Appends a Git branch onto another branch or commit, permanenetly changing history

The Basics:

Developer Workflow and Git Lifecycle:

1. pull* Latest Version of Remote Repo (*clone Once, then pull for changes)
2. checkout the Created Branch
3. Write code changes
4. Add files to staging area
5. commit to Local Git Repo
6. Push Branch to Remote Repo
7. Create pull request and resolve conflicts
8. Merge to main (then delete branch)
9. GO BACK TO 1.

Merge Conflicts:

It's important to try to avoid merge conflicts by merging often, keeping branches short lived and communicating with teammates but no matter how careful you are conflicts WILL happen. Luckily git also helps you resolve these conflicts.

Commit Reversals:

DONT EVERY COMMIT SECRETS LIKE TOKENS OR PASSWORDS! Even with this warning at some point in my career ill probably accidently commit a secret to code.

First off don't try to kide it. Be transparent and communicate with anyone that might be affected by what happened. Second. if possible, revoke whatever secret was exposed. this might be simple or very difficult or completely impossible. This is where being transparent about what happened is important because if you start revoking tokens or changing passwords chances are someone else is going to need to know. Third, remove the secret from the repository and from Git history. Even if the secret is revoked this is still a good idea and will help repair your wounded image by demonstrating to your teammates that you do know to use git and that you do care about security and can be trusted with sensitive data.

Option 1: Git reset

Using a Git reset, we can get rid of any commits after a specific point. As long as we don't use reset-hard the files themselves will not be changed, only the Git history will be impacted. This is a good option if the trouble commit is near or at the current head of our Git repository. To Undo a commit with reset:

1. Use git log to find the hash of the commit just before the credentials were added.
2. git reset 1a2b3c4 where 1a2b3c4 are the first 7 characters of the hash you just found.
3. Edit any files neccessary to remove the credentials
4. Commit the sanitized files.
5. Push the changes using the -f flag.

This is a simple and fairly easy approach, however it has the side effect of combining all commits after the error into one. The actual changes will be preserved, but each individual commit message will be lost.

Option 2: Git rebase

Using a git rebase, we can remove only a single commit. which is useful for a commit that is not near the head, or for keeping important commit messages.
To rebase:

1. Get the hash value of the commit containing credentials.
2. Start an interactive rebase on that commit 'git rebase -i 1a2b3c4^' where 1a2b3c4 are the first 7 characters of your hash and the last character is a '^'.
3. Change 'pick' to 'edit' for the commit you want to change, and then exit the file.
4. The rebase will stop when the 'edit' point is reached. Sanitize the commit by removing the credentials wherever necessary.
5. Add the change and run 'git commit --amend' (Do not change anything in the amend).
6. Continue with the rebase: 'git rebase --continue'
7. Push the changes to remote using the -f flag

This is a more involved approach, but allows all commits and history to be preserved.

These approaches both change Git history, which will require a force push to propagate to the remote repository. Make sure you can force push, or ask an administrator to do it for you if necessary. Rewriting Git history is a destructive process, and should only ne carried out when necessary for security.

Git Alternatives:

While git has become the de facto standard there are other version control systems you might encounter. Subversion was very commonly used before git came along and is sometimes used with older projects that hav enot been migrated to a newer VCS. An important distinction between git and subversion is that subversion relies on a central repository while git is distributed. Mercurial is a more modern alternative to git which has similar features is well supported but not nearly as popular as git.
